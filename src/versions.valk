
use valk:json
use valk:fs
use valk:time
use valk:ansi

class Versions {
    vpm_latest: String
    vpm_current: String
    valk: ?String
}

fn get_versions() Versions {
    let cd = vpm_dir()
    let path = cd + "vpm.json"
    let data = fs:read(path) !? "{}"
    let conf = json:decode(data) !? json:new_object()

    let vpm_latest = conf.get("valk-latest").string()
    let valk_latest : ?String = conf.get("vpm-latest").string()
    let last_update = conf.get("last-update").int().to(uint)

    if vpm_latest.is_empty() : vpm_latest = #STR(VERSION)
    if valk_latest.is_empty() : valk_latest = null

    let now = time:microtime()
    let one_day : uint = 1000 * 1000 * 60 * 60 * 24
    if now - last_update > one_day {
        api_get_versions() -> res {
            if res.has("vpm") && res.has("valk") {
                vpm_latest = res.get("vpm").string()
                valk_latest = res.get("valk").string()

                conf.set("vpm-latest", res.get("vpm"))
                conf.set("valk-latest", res.get("valk"))
                conf.set("last-update", json:new_int(now.to(int)))
                fs:write(path, conf.encode(true)) _
            }
        }
    }

    return Versions {
        vpm_latest: vpm_latest
        vpm_current: #STR(VERSION)
        valk: valk_latest
    }
}

fn vpm_is_up_to_date(vv: Versions) bool {
    let v_current = Version.new(vv.vpm_current) !? null
    let v_latest = Version.new(vv.vpm_latest) !? null
    return isset(v_current) && isset(v_latest) && v_current >= v_latest
}

fn check_vpm_versions(vv: Versions) {
    if vpm_is_up_to_date(vv) {
        if ansi:supported() : println("# vp is " + "up-to-date".ansi.green())
        else : println("# vp is " + "up-to-date")
    } else {
        println("# There is a new vp version available: " + vv.vpm_latest)
        println("# Update command: vp self-update")
    }
}

fn get_version_from_config() String {
    let path = fs:cwd() + div() + "valk.json"

    let data = fs:read(path) ! error("No config found: " + path)

    let json = json:decode(data) ! error("Invalid json in: " + path)
    let version = json.get("valk").string()
    if version.is_empty() : error("No version specified in: " + path)
    return version
}

fn is_valid_version(v: String) bool {
    Version.new(v) ! return false
    return true
}
